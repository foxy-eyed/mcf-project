# ДЗ#1

Содержание
 - [ES модель](#es-модель)
 - [Data model](#data-model)
 - [Общая модель коммуникаций](#общая-модель-коммуникаций)
 - [Комментарии](#комментарии)

## ES модель

![ES модель](https://github.com/foxy-eyed/mcf-project/blob/hw-1/homework-1/img/ES_model.jpg)

[Открыть в Miro](https://miro.com/app/board/uXjVNNeyOQc=/?share_link_id=321736457182)

Выделенные контексты:
  - Всё, что связано с заказами и их выполнением:
    - Кабинет клиента (создание и управление заказами);
    - Кабинет воркера (исполнение заказов);
    - BackOffice для менеджеров (управление услугами, контроль качества, ручные вознаграждения исполнителям);
    - Биллинг;
    - Матчер (подбор воркера и оценка стоимости);
  - Всё связанное с наймом:
    - Кабинет кандидата (отклик и тестирование);
    - BackOffice для HR-менеджеров (работа с откликами, управление тестами);
  - Склад.
     
### Заметки к ES модели
  - История [US-010] в схеме не отражена, потому что я сделала вывод, что отдельной регистрации тестировщиков в системе
не будет (предполагаю SSO с существующей системой Happy Cat Box).
  - В [US-030] неявно упоминается, что клиент может отменить заказ, добавила соотв. событие.
  - Обнаружено противоречение между [US-030] (статусы задачи может менять только клиент) и [US-110]
(заказ автоматически проваливается). Я посчитала логичным проваливать заказ автоматически по крону: 
проверяем все текущие заказы, у которых наступило время выполнения, но они до сих пор не взяты в работу 
(кот-воркер на нажал соотв. кнопку в приложении).
  - История со скидками [US-040] не влияет на ES модель.
  - [US-070] — эта история выглядит избыточно на данный момент, потому что в конечном итоге статус выполнения заказа
зависит от команды заказчика. Возможно, тут в будущем потребуется выделить отдельный статус заказа, по которому можно 
будет понять, что в реальности клиент заказ принял, а в системе по какой-то причине не отметил.
  - [US-101] — детали реализации, которые не влияют на модель.
  - [US-081] — не пользовательская история, а скорее ограничение, которое стоит учитывать при выборе решения. 
В частности, ф-л приема заявок вместе с процессом их рассмотрения имеет смысл сразу же вынести в отдельный микросервис,
чтобы его падение в случае DDOS не зааффектило остальные части системы.
  - [US-250] и [US-260] со всеми вложенными историями отображена как внешняя система, ниже есть пояснение.

## Data model

![Data model](https://github.com/foxy-eyed/mcf-project/blob/hw-1/homework-1/img/data_model.jpg)

[Открыть в Miro](https://miro.com/app/board/uXjVNMS8xzo=/?share_link_id=43973897252)

### Заметки к модели данных

Так вышло, что при построении ES-модели я выделила много небольших контекстов, и уже в процессе рисования на ней связей
между событиями и read-моделями стало понятно, что ряд контекстов очень тесно связан на уровне данных.
Поэтому к моменту построения модели данных я уже решила оъединить их в более крупные: заказы, склад и найм. 
Таким образом большинство стриминговых событий исчезли со схемы.

## Общая модель коммуникаций

![Communication model](https://github.com/foxy-eyed/mcf-project/blob/hw-1/homework-1/img/system_schema.jpg)

[Открыть в Miro](https://miro.com/app/board/uXjVNLnCn5E=/?share_link_id=938097208728)

### Заметки к модели коммуникаций

В итоге получается, что полученные три больших контекста связаны минимумом стриминговых событий:
  - стримить данные о принятых воркерах из **Найма** в **Заказы** после приёма;
  - стримить данные о заказах, взятых в работу, из **Заказов** на **Склад** для комплектации.

Бизнес-события, которые как-то торчат наружу — изменение статуса заказов для тотализатора.

Обе этих коммуникации я предлагаю реализовать с помощью православных HTTP запросов к API консьюмеров. 
Поскольку нам не нужно получать ничего в ответ, эти запросы имеет смысл делать асинхронно в бэкграунд-процессе.

## Комментарии
  - Я бы склонила заказчика вынести тотализатор за границы системы и реализовать идею no-code инструментами (нужен рисёч). 
Мы можем отсылать хуки наружу на события «Заказ выполнен» и «Заказ провален», на которые будет завязан пересчёт
вознаграждений в какой-нибудь условной google sheets.
Аргументы:
    - Это побочный ф-л, который не является приоритетным по словам самого заказчика;
    - Простая логика, для которой не потребуется хитрого кода и дальнейшей поддержки;
    - Серая зона — лучше держать отдельно;
    - Озвучена готовность часть процессов вести в условной «тетрадке».
  - Чисто теоретически можно было бы рассмотреть вариант использования внешних решений для процессов найма. Но я решила,
что стоит оставить эту функциональность в своих руках, потому что озвучено требование «Для бизнеса критично проверять
новые гипотезы по отсеву котов и изменять уже существующие с максимальной скоростью и надёжностью».
Это значит, что нам потребуется гибкость в настройке тестовых испытаний.
